## Searching, Sorting & `std::vector` Type

#vector #search #sort

### List Processing

#list #array

**List**: Collection of values of the same type.
**Array**: Convenient place to store a list.

Steps:
- Search the an item
- Sort the list
- Insert an item
- Delete an item
- Print the list

### Sequential Search

#sequentialsearch

**Sequential Search** algorithm:
- Searches a list by comparing each el, one by one to the target.
- Requires half the number of els in the list for a successful search.
- Does not require list to be sorted.
	- If sorted -> [[16#Binary Search|Binary Search (16)]]

Steps:
1. Start at the first element of the list.
2. Compare each element in the list with target val.
3. Continue until:
	- Target found
	- Target could not be found

### Binary Search ([[15#Divide-and-Conquer Algorithm(s)|Divide-And-Conquer (15)]])

#binarysearch

Much faster than sequential search, especially for large lists.
- List must be sorted.

[[15#Divide-and-Conquer Algorithm(s)|Divide-and-Conquer (15)]] Approach:
1. Compare the target val with the middle el.
2. If target < middle el -> search lower half of list.
3. If target > middle el -> search upper half of list.

#### Performance

For a sorted list of length $n$, the max number of comparisons is $O(\log n)$.
- Each iteration halves the size of the list.

### Selection Sort

#selectionsort

**Selection Sort**: Algorithm that rearranges a list by repeatedly finding the smallest el in the unsorted position and moving it to the correct spot.

Steps:
- Find the smallest el in unsorted portion of list.
- Move it to the beginning of the unsorted position by swapping the el currently there.
- Repeat with next smallest el in remaining unsorted els until list is fully sorted.

![[sort_1.png]]
_Figure 15.1 - Selection Sort Visualized_

#### Example

For int arr[5] = {5, 3, 4, 1, 2};
1. Pass 1: Find smallest el (1) and place it at the start.
	-  After Pass 1: {1, 3, 4, 5, 2}
2. Pass 2: Find next smallest el (2) and place it in the second position.
	-  After Pass 2: {1, 2, 4, 5, 3}
3. Pass 3: Find next smallest el (3) in the unsorted portion.
	- After Pass 3: {1, 2, 3, 5, 4}
4. Pass 4: Move last unsorted el (4) into position, completing the sort.
	- After Pass 4: {1, 2, 3, 4, 5}

### Bubble Sort

#bubblesort

**Bubble Sort**: Repeatedly compares adjacent elements and swaps them if they are in the wrong order.
- Pushes larger els towards the end of the list with each pass, while smaller els "bubble up" to the start.
- Stops when no swaps occur in a complete pass through the list.

#### Example

For int arr[5] = {5, 3, 4, 1, 2};
1. Pass 1: Compare and swap adjacent elements to move the largest element (5) to the end.
	- After Pass 1: {3, 4, 1, 2, 5}
2. Pass 2: Repeat the process, moving the second largest element (4) toward the end.
	- After Pass 2: {3, 1, 2, 4, 5}
3. Pass 3: Continue until the entire list is sorted.
	- After Pass 3: {1, 2, 3, 4, 5

### Insertion Sort

#insertionsort

**Insertion Sort**: Sorts a list by building a sorted portion, one el at a time.
- Each el is taken from the unsorted position into its correct position in the sorted position.

#### Example

For int arr[5] = {5, 3, 4, 1, 2};  
1. Pass 1: Insert 3 in the correct position within the sorted portion ({5}).  
	- After Pass 1: {3, 5, 4, 1, 2}  
2. Pass 2: Insert 4 in the correct position in the sorted portion ({3, 5}).  
	- After Pass 2: {3, 4, 5, 1, 2}  
3. Pass 3: Insert 1 in the correct position in the sorted portion ({3, 4, 5}).  
	- After Pass 3: {1, 3, 4, 5, 2}  
4. Pass 4: Insert 2 in its correct position, completing the sort.  
	- After Pass 4: {1, 2, 3, 4,

### Merge Sort

#mergesort

[[15#Divide-and-Conquer Algorithm(s)|Divide-and-Conquer (15)]] Approach:
1. Divide the list into $n$ sub-lists, each containing one el (a list of one el is considered sorted).
2. Repeatedly merge sub-lists to produce new sorted sub-lists until there is only one remaining sorted listed.
_Merging is key; Two sorted sub-lists into a single sorted list_.

![[sort_3.png]]
_Figure 15.2 - Merge Sort Visualized_
#### Example

For int arr[5] = {5, 3, 4, 1, 2};
1. Pass 1: Divide array into single-element sublists and start merging pairs in order.
	- After merging first pairs: {3, 5, 1, 4, 2}
2. Pass 2: Continue merging sorted sublists.
	- After Pass 2: {1, 2, 3, 4, 5}
3. Pass 3: Complete the merge, resulting in the sorted

#### Performance

Requires $O(n)$ space (twice as much memory)

It is a stable sort and is efficient for handling sequential access data.

It is often the best choice for sorting linked lists.
- It can be implemented to require $O(1)$ extra space.
- The slow random access performance of linked lists makes other algorithms less efficient.

### Quick Sort

#quicksort

**Quick Sort**: Highly efficient, comparison-based algorithm.

[[15#Divide-and-Conquer Algorithm(s)|Divide-and-Conquer (15)]] Approach:
1. Select a _pivot_ el from the list.
2. Rearrange the els so:
	1. Elements less than _pivot_ are on the left.
	2. Elements greater than the _pivot_ are on the right.
3. Recursively apply the same process to the left and right sub-lists.
_Pivot selection and partitioning steps are key_.

#### Example

For int arr[5] = {5, 3, 4, 1, 2};
1. Select Pivot and Partition:
	- Choose last element arr[4] = 2 as the pivot.
	- Rearrange elements so that elements less than 2 are on the left, and elements greater than 2 are on the right.
	- After Partition: {1, 2, 4, 5, 3}
2. Recursive Sort of Left and Right Sub-Arrays:
	- Left sub-array: {1}
	- Right sub-array: {4, 5, 3}
3. Continue Sorting:
	- Sort the right sub-array {4, 5, 3}.
	- Select 3 (last element) as the pivot for this sub-array and partition around it.
	- After Partition: {1, 2, 3, 4, 5} (sorted array)

#### Performance

Suitable for large datasets and is commonly used in programming libraries.

Average case time complexity is $O(n \log n)$, but the worst case is $O(n^2)$.
- Worse case occurs when the pivot choices create highly unbalanced partitions (_i.e._ pivot is consistently the smallest or largest el).

Quick sort is typically faster than $O(n \log n)$ algorithms such as merge sort.
- Has smaller constant factor.
- Operates in-place, requiring minimal extra memory.

### Quick Sort V.S. Merge Sort

#quicksort #mergesort 

Quick sort is faster for most applications and is often default sorting algorithm (`std::sort`).

| Algorithm  | Key Traits                          | Space Usage              | Best Use Case                         |
| ---------- | ----------------------------------- | ------------------------ | ------------------------------------- |
| Quicksort  | In-place, generally fast on average | O(log n) auxiliary space | Random-access data (e.g., arrays)     |
| Merge Sort | Stable, predictable performance     | O(n) auxiliary space     | Linked lists / sequential-access data |
_Figure 15.3 - Quick Sort V.S. Merge Sort_

### Performance Metrics

#bigo #linearsearch #binarysearch #bubblesort #selectionsort #insertionsort #mergesort #quicksort #heapsort #bucketsort #radixsort #timsort #shellsort

![[sort_2.png]]
_Figure 15.4 - Big-$O$ Complexity_

| Algorithm      | Best Time  | Average Time   | Worst Time     | Worst Space |
| -------------- | ---------- | -------------- | -------------- | ----------- |
| Linear Search  | O(1)       | O(n)           | O(n)           | O(1)        |
| Binary Search  | O(1)       | O(log n)       | O(log n)       | O(1)        |
| Bubble Sort    | O(n)       | O(n^2)         | O(n^2)         | O(1)        |
| Selection Sort | O(n^2)     | O(n^2)         | O(n^2)         | O(1)        |
| Insertion Sort | O(n)       | O(n^2)         | O(n^2)         | O(1)        |
| Merge Sort     | O(n log n) | O(n log n)     | O(n log n)     | O(n)        |
| Quick Sort     | O(n log n) | O(n log n)     | O(n^2)         | O(log n)    |
| Heap Sort      | O(n log n) | O(n log n)     | O(n log n)     | O(n)        |
| Bucket Sort    | O(n + k)   | O(n + k)       | O(n^2)         | O(n)        |
| Radix Sort     | O(nk)      | O(nk)          | O(nk)          | O(n + k)    |
| Tim Sort       | O(n)       | O(n log n)     | O(n log n)     | O(n)        |
| Shell Sort     | O(n)       | O((n log n)^2) | O((n log n)^2) | O(1)        |
_Figure 15.5 - Performance of Searching & Sorting Algorithms_

### `std::vector` Type (`class`)

#vector 

Only a fixed number of els can be stored in an array.
- Inserting and removing els causes shift of remaining els.

`std::vector` type implements a list. Can be referred to by:
- vector container
- vector
- vector object
- object

You can use range-based for loop in C++11 Standard to process vector elements

```cpp
for (auto item : list) {    // For each item in list
	std::cout << item << '\n';
}
```
_Figure 15.6 - Range-Based For Loop_

You can also initialize a vector obj with an `initializer_list`:
 ```cpp
  std::vector<int>int_list = { 13, 75, 28, 35 };    // Canonical
  ```
 ```cpp
  std::vector<int>int_list{ 13, 75, 28, 35 };       // Modern
  ```
 ```cpp
  auto int_list = std::vector{ 13, 75, 28, 35 };    // Auto
  ```
_Figure 15.7 - Vectors With `initializer_list`_
