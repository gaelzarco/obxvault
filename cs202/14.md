## Exception Handling

#exceptionhandling #assert #trycatch #throw #stackunwinding

An __Exception__ is an undesirable event detectable during program execution.
- May or may not want the program to terminate when an exception occurs.

### Handling Exceptions Within a Program

#assert

`assert` function:
- Checks is expression meets certain condition(s).
- If conditions are not met, it terminates the program.
- __ONLY USE IT TO DEBUG__

You can add exception-handling code where an error can occur.

### C++ Mechanisms of Exception Handling

#trycatch

`try`/`catch` block; used to handle exceptions.
- Exception must be thrown in a `try` block and caught by a `catch` block.
- C++ provides support to handle exceptions via a hierarchy of classes.

### `try`/`catch` Block

#trycatch #exception 

Statements that may generate an exception are placed in a `try` block.
- Also contains statements that should not be executed if an exception occurs.
- `try` block is followed by one or more `catch` blocks.

```cpp
try {
	// Statements
} catch (dataType1 identifier) {
	// Exception-handling code
} catch (dataType2 identifier) {
	// Exception-handling code
} catch (...) {
	// Exception-handling code
}
```
_Figure 14.1 - `try`/`catch` Syntax_

`catch` block:
- Specifies the type of exception it can catch.
- Contains an exception handler.
- If the heading contains `...` in place of params, it will function as a _catch-all_.

If no exception is thrown in a `try` block:
- All `catch` blocks are ignored.
- Execution resumes after the last `catch` block.

If an exception is thrown in a `try` block:
- Remaining statements (in block) are ignored (similar to `return` but within the context of the `try`/`catch` scope).
- Program searches `catch` blocks in order, looking for the appropriate exception handler.
 - Type(Exception) == Type(identifier)  -> `catch` block executes _(Figure 14.1)_.
	- Remaining `catch` blocks are ignored.

`catch` block can have at most one `catch` block param.
- `catch` block param becomes a placeholder for the value thrown.

### Throwing An Exception

#throw #exception

For `try`/`catch` to work, the exception must be thrown in the `try` block.

```cpp
throw expression;
```
_Figure 14.2 - `try` Syntax_
- `expression` is a constant value, variable, or object.
- Object being thrown can be a specific object or an anonymous object.

In C++, an exception is a __value__.

### Order of `catch` Blocks

`catch` blocks can catch:
- All exceptions of a specific type.
- All types of exceptions.

A `catch` block with `...` catches any type of exception.
- If used, it should be the last `catch` block of that sequence.
- __Be careful of `catch` block order.__

### Using C++ Exception Classes

#exception #exceptionclasses #what

C++ provides support to handle exceptions via a hierarchy of classes.
- The class `std::exception` is the base class for most standard errors.

Function `what()`:
- Contained in class `std::exception`
- Returns a string containing an appropriate error message.

All derived classes of the class `std::exception` override the function `what()` to issue their own error messages.
- `what()` is a virtual function.

`std::exception` -> `std::logic_error` -> `std::out_of_range` -> __YOUR DERIVED CLASS__
_Figure 14.3 - `std::exception` Inheritance Diagram_
- Derived exception class types should appear before their base class type in the chain of `catch` blocks.

Two subclasses of exception (defined in `stdexcept`):
- `logic_error` subclasses:
	- `invalid_argument`: For use when illegal args are used in a function call.
	- `out_of_range`: String subscript out of range error.
	- `length_error`: If a length greater than the max allowed for a `std::string` obj is used.
- `runtime_error` subclasses:
	- `overflow_error`
	- `underflow_error`

### Creating Your Own Exception Classes

#exception #exceptionclasses #throw #what

If you create your own exceptions, C++ will use the same mechanism to process them.
- `throw` statement: used to throw your own exceptions
- Any class can be an exception class
	- How you use it determines whether it is an exception class.

```cpp
class MyException : public std::exception {
public:
    const char* what() const noexcept override {
        return "Error occurred!";
    }
};
```
_Figure 14.4 - Custom Exception Class Example_

Exception classes with member variables include:
- Constructors
- The function `what()`

### Re-throwing and Throwing an Exception

#rethrow #throw #exceptions

`throw` called -> control is passed to `catch` blocks which either:
- Handles exception, or partially processes it and then re-throws it.
- Re-throws another exception for the calling environment to handle.

This enables exception-handling code to exist in a single place.

```cpp
#include <iostream>
#include <stdexcept>

// Catches the error from func2 and ouputs a message
int main () {
	try {
		func1();
	} catch (...) {
		std::cout << "Exception thrown in call stack." << '\n';
	}
	
	return 0;
}

// The error thrown in func2 is caught here and re-thrown
void func1() {
	try {
		func2();	
	} catch (...) {
		// Error from func 2 is rethrown and passed down the call stack
		throw;
	}
}

// This function throws an error
void func2() {
	throw expression;
}
```
_Figure 14.5 - Re-throw in Action_
- `expression` is a constant value, variable, or object.
- Object being thrown can be a specific object or an anonymous object.

A function specifies the exceptions it throws in its heading using the `throw` clause.
- Dynamic exceptions are deprecated as of C++17.

```cpp
void foo(int x) throw (int, string, divisionByZero) {
	// Include the appropriate throw statements
}
```
_Figure 14.6 - `throw` in Function Signature_

```cpp
#include <iostream>
#include <stdexcept>

void testFunction() {
    // An error condition occurs here
    throw std::runtime_error("An error occurred in testFunction");
}

int main() {
    try {
        testFunction();
        // Code here will not execute if an exception is thrown above
    } catch (const std::runtime_error& e) {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }

    return 0;
}
```
_Figure 14.7 - `throw` in Functions Usage_
### Exception-Handling Techniques

#exceptionhandling #exceptionhandlingtechniques #logerrors #fixerrors #terminateprogram

Exception occurs -> three choices (usually):
1. Terminate the program.
2. Include code to recover from an exception.
3. Log the error and continue.

#### Terminate the program

Sometimes its best to terminate the program when an exception occurs.
- _i.e._ Input file does not exist when the program executes.

#### Fix Errors and Continue

_i.e._ A user inputs a letter instead of a number.

#### Log Errors and Continue

_i.e._ Program is designed to run a nuclear reactor to continuously monitor a satellite.
- It cannot be terminated if an exception occurs.

When an exception occurs:
- The program should write the exception into a file and continue to run.

### Stack Unwinding

#stackunwinding

When an exception is thrown in a function, the function can:
- Do nothing
- Partially process the exception and throw the same exception or a new one.
- Throw a new exception.

In each case, the function call-stack is unwound so that the exception can be caught in the next `try`/`catch` block.

```cpp
#include <iostream>
#include <stdexcept>

// Exception is caught at the end of the call stack (main)
int main () {
	try {
		func1();
	} catch ( const std::logic_error& ex ) {
		// Catch block processes the thrown expression
		std::cout << "Exception caught!" << '\n';	
	} catch ( ... ) {
		// ... other logic
	}
}

void func1() {
	func2();
}

void func2() {
	func3();
}

// Error is thrown here
void func3() {
	throw std::logic_error("EXCEPTION");
}
```
_Figure 14.8 - Stack Unwinding_

`func3()` -> `func2()` -> `func1()` -> `main()`
_Figure 14.8 - Call Stack Visualized_
- Figure 14.7 demonstrates how functions are placed onto the call stack (LILO).
- The call stack contains markers to where a program was previously running before moving to the next function.
	1. `main()` calls `func1()` -> `main()` is added to call stack.
	2. `func1()` calls `func2()` -> `func1()` is added to the stack.
	3. `func2()` calls `func3()` -> `func2()` is added to the stack.
	4. `func3()` is pushed onto the stack, executes first, and is popped off before returning to the caller (`func2()`).
		- The rest of the caller's code executes before returning to it's respective caller until all functions are executed.

When it is unwound:
- The function in which the exception was not caught and/or re-thrown terminates.
- Memory for its local variables is destroyed.

Stack unwinding continues until:
- A `try`/`catch` block handles the exception.
- The program does not handle the exception.
	- `std::terminate()` is called to terminate the program.