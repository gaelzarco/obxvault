## Overloading and Templates

#overloading #operatoroverloading #this #friendfunctions #pointers #classes #templates #functiontemplates #classtemplates #cpprandom 

### Introduction

__Templates__ enable you to write generic code for related functions and classes.

__Function Templates__ simplify function overloading.

### Why Operator Overloading Is Needed

```cpp
clockType myClock(8, 23, 34);
clockType yourClock(4, 5, 30);

// Which do you prefer?

myClock.printTime();
myClock.incrementSeconds(); 
if (myClock.equalTime(yourClock)) { 
	//... 
} 

// Or

cout << myClock;
++myClock; 
if (myClock == yourClock) { 
	//...
}
```
_Figure 13.1 - Operator Overloading in Action._

Assignment and member selection are the only built-in operations on classes.
- Other operators cannot be applied directly to class objects.

__Operator Overloading__ extends the definition of an operator to work with a user-defined data type.
- C++ allows you to extend the definitions of most of the operators to work with classes.

### Operator Overloading

#operatoroverloading #newoperator

Most C++ ops can be overloaded to manipulate class objects.

__Operator Function__ is a function that overloads an operators.
- Use reserved word `operator` followed by the op as the function name.

### Syntax for Operator Functions
 
 #operatorfunctions #syntax

```cpp
returnType operator operatorSymbol(formal param list)
```
_Figure 13.2 - Operator Function in Action_
- Is a value-returning function.
- `operator` is a reserved word.

To overload an op for a class:
- Include the op function declaration in the class def.
- Write the def of the op function.

### Overloading an Operator: Restrictions

#overloadingrestrictions 

1. __CANNOT__ change the precedence of the op.
2. Associativity __CANNOT__ be changed.
3. Default params __CANNOT__ be used.
4.  __CANNOT__ change num of params.
5. __CANNOT__ create _new_ operators.
6. __CANNOT__ overload:
	- `.` Member Access Operator
	-  `.*` Pointer to Member Access Operator
	- `::` Scope Resolution Operator
	- `?:` Ternary Conditional Operator
	- `sizeof` Sizeof Operator
	- `typeid` Type Identification Operator
7. How the op works with built-in types remains the same
8. __CAN__ overload for user-defined objects or a combo of user-defined and built-in objects.

### Pointer `this`

#this #thispointer

Every object of a class maintains a (hidden) pointer to itself called `this`.
- When a member func is invoked by an obj, the pointer `this` refers to the calling obj.

### Friend Functions of Classes

#friendfunctions

__Friend Function__ is a non-member func of the class that has access to all members of the class.
- Generally used for non-member funcs that need to access `private`/`protected` data.
- Use the reserved word `friend` in the func prototype in the class def.
- Explicitly declared in the class.

```cpp
class classIllusFriend {
	friend void two(/*params*/);
	// ...
}
```
_Figure 13.3 - Friend Functions in Action_

### Definition of a `friend` Function

#friendfunctions 

`friend` does not appear in the heading of the func's def.
- When writing the `friend` fun def:
	- Name of the class and scope resolution op are __NOT__ used.

```cpp
friend void two(/*params*/) {
	// ...
}
```
_Figure 13.4 - Friend Function Definition_

### Operator Functions as Member and Non-Member Functions

#operatorfunctions #non-memberfunctions

To overload `()`, `[]`, `->` or `=` for a class, the func __MUST__ be a member of the class.

Suppose `op` is overloaded for `opOverClass`:
- If the leftmost operand of `op` is not an obj of the class for which the operator is overloaded, the overloading func __MUST__ be a non-member (_friend_) of the class.
- If the overloading func for `op` is an obj of `opOverClass`, then when applying op on objs of type `opOverClass`, the leftmost operand must be of type `opOverClass`.

### Overloading Binary Operators

#overloadingbinaryoperators

If `#` represents a binary op (e.g. `+` or `==`) that is to be overloaded for `rectangleType`
- It can be overloaded as either a member func of the class or as a `friend` func.

### Overloading the Binary Operators as Member Functions

#overloadingbinaryoperators #memberfunctions

```cpp
returnType operator#(const className&) const;
```
_Figure 13.5 - Overloading Binary Operator Function Prototype_

```cpp
returnType className::operator#(const className& otherObj) const {
	// Algorithm to perform the op
	return value;
}
```
_Figure 13.6 - Overloading Binary Operator Function Definition_

### Overloading the Stream Insertion Operator

#streaminsertion #overloadingstreamoperators
```cpp
std::ostream& operator<<(std::ostream& output, const className& obj);
```
_Figure 13.7 - Overloading Stream Insertion Operator Function Prototype_

```cpp
std::ostream& operator<<(std::ostream& output, const className& obj) {
	// e.g. output << obj.member;
	
	return output;    // Return the stream obj
}
```
_Figure 13.7 - Overloading Stream Insertion Operator Function Definition_

### Overloading the Stream Extraction Operator

#streamextraction #overloadingstreamoperators

 ```cpp
std::istream& operator>>(std::istream& input, const className& obj);
```
_Figure 13.8 - Overloading Stream Extraction Operator Function Prototype_

```cpp
std::istream& operator>>(std::istream& input, const className& obj) {
	// e.g. input >> obj.member;
	
	return input;    // Return the stream obj
}
```
_Figure 13.9 - Overloading Stream Extraction Operator Function Definition_

### Overloading the Copy Assignment Operator

#copyassignmentoperator

 ```cpp
className& operator=(const className& other);
```
_Figure 13.10 - Overloading Copy Assignment Operator Function Prototype_

 ```cpp
className& operator=(const className& other) {
	if (this != &other) {
		// Algorithm to copy other into this obj
	}

	// Return the assigned obj
	return *this;
}
```
_Figure 13.11 - Overloading Copy Assignment Operator Function Definition_

### Overloading the Unary Operator

#unaryoperator #overloadingunaryoperator

To overload for a class:
- If the op func is a member of the class, it has no params.
- If the op func is a non-member of the class (i.e. a `friend` func), it has one param.

### Overloading the Pre-Increment (`++`) & Pre-Decrement (`--`) Operators

#pre-incrementoperator #pre-decrementoperator

__General Syntax for `++` as `member` function__:
```cpp
className& operator++();
```
_Figure 13.12 - Overloading Pre-Increment Op as a `member` Function Prototype_

```cpp
className& className::operator++() {
	// Increment..
	
	return *this;
}
```
_Figure 13.13 - Overloading Pre-Increment Op as a `member` Function Definition_

__General Syntax for `++` as non-member function__:
```cpp
friend className operator++(className& obj);
```
_Figure 13.14 - Overloading Pre-Increment Op as a Non-Member Function Prototype_

```cpp
className operator++(className& obj) {
	// Increment..
	
	return obj;
}
```
_Figure 13.15 - Overloading Pre-Increment Op as a Non-Member Function Definition_

### Overloading the Post-Increment (`++`) & Post-Decrement (`--`) Operators

#post-incrementoperator #post-decrementoperator

__General Syntax for `++` as `member` function__:
```cpp
className operator++(int);
```
_Figure 13.16 - Overloading Post-Increment Op as a `member` Function Prototype_

```cpp
className className::operator++(int u) {
	className temp = *this;    // Copy the obj value
	
	// Increment..
	
	return temp;    // Return incremented val
}
```
_Figure 13.17 - Overloading Post-Increment Op as a `member` Function Definition_

__General Syntax for `++` as non-member function__:
```cpp
friend className operator++(classname&, int);
```
_Figure 13.18 - Overloading Post-Increment Op as a Non-Member Function Prototype_

```cpp
className operator++(classname& other, int u) {
	className temp = other;    // Copy the obj value
	
	// Increment..
	
	return temp;    // Return incremented val
}
```
_Figure 13.19 - Overloading Post-Increment Op as a Non-Member Function Prototype_

### Operator Overloading: `member` VS Non-Member

#binaryarithmeticoperator

Binary arithmetic op `+` can be overloaded either way.
- As a `member` function `+` has direct access to data members of one of the objs - Need to pass only one obj as param.
- As a non-member function `+`, you must pass both objs as params and code may be somewhat clearer.

### Overloading the Array Index (Subscript) Operator `[]` 

#arrayindexoperator #subscripts

To declare as a `member`function of a class for non-constant arrays:
```cpp
Type& operator[](int index);
```
_Figure 13.20 - Overloading Array Index Op as a `member` Function For Non-Constant Arrays Prototype_

To declare as a `member`function of a class for constant arrays:
```cpp
const Type& operator[](int index) const;
```
_Figure 13.21 - Overloading Array Index Op as a `member` Function For Constant Arrays Prototype_

### Classes and Pointer Member Variables (Revisited)

#pointermembervariables #classes #ruleofthree

Recall that the copy assignment operator copies member variables from one object to another of the same type.
- Shallow copy on pointer member variables.

Classes with pointer member variables must implement the __Rule of Three__
- Include the destructor
- Include the copy constructor
- Explicitly overload the copy assignment operator

### Resource Management

#cppresourcemanagement #movesemantics #ruleoffive

__Move Semantics__: Optimize obj transfers to reduce unnecessary copying

__Rule of Five__: Rule of three + more ops.

### Move Semantics 

#cppresourcemanagement #movesemantics #moveconstructor #moveassignmentoperator

Introduced in C++ 11 that optimizes obj transfers and is useful for managing resources like dynamic memory and large data structures.

In modern C++, move semantics are achieved by implementing:
- Move constructor
- Move assignment operator
	- Minimizes unnecessary copying for better performance

#### Move Constructor

#rvaluereference

`&&`- `rvalue` reference
- Used to represent when an "obj is about to die" and _steal_ its resources instead of copying.

```cpp
class MyString {
public:
	MyString(MyString&& other) noexcept {
		// Transfer data from `other` to `this` obj
		m_data = other.m_data;    // Take-over pointer
		m_data = other.m_size;    // Copy size
		
		// Clear `other` state safely
		other.m_data = nullptr;
		other,m_size = 0;
	}
}
```
_Figure 13.22 - Move Constructor Definition_
- Ensure proper clean-up before move.

```cpp
MyString CreateString() {
	MyString temp("Hello World");
	// `temp` is a temp obj; move constructor transfers its resources
	return temp;    // <- Move constructor called here
}
```
_Figure 13.23 - Move Constructor In Action (Avoids Expensive Copy)_
- Resources are transferred efficiently by avoiding a copy.

#### Move Assignment Operator

#moveassignmentoperator

```cpp
MyString& operator=(MyString&& other) noexcept {
	if (this != &other) {    // Protect against self-assignment
		// Clean-up existing resources
		delete[] m_data;
		
		// Transfer ownership from `other`
		m_data = other.m_data;
		m_size = other.m_size;
		
		// Clear `other` state safely
		other.m_data = nullptr;
		other,m_size = 0;
	}
	
	return *this;
}
```
_Figure 13.24 - Move Assignment Operator Definition_
- Ensure proper clean-up before transferring ownership.

```cpp
MyString str1("Hello");
MyString str2("World");

str1 = std::move(str2);    // Move assignment is called here
```
_Figure 13.25 - Move Assignment Operator In Action_
- After the move, `str1` takes ownership of the resources previously held by `str2` without unnecessary copying.

Move semantics reduce unnecessary copying and improves performance.
- Especially beneficial when dealing with large data structures.
- You can optimize your C++ code for resources management.

### Rule of Five

#cppresourcemanagement #movesemantics #ruleoffive

1. Destructor
2. Copy Constructor 
3. Copy Assignment Constructor
4. Move Constructor
5. Move Assignment Constructor
_With the introduction of move semantics in C++ 11, the Rule of Five was created and emphasizes the importance of both move ops and copy ops._

### Function Overloading

#functionoverloading

Refers to having several functions with the same name, but different params.
- Param list determines which function to execute.
- Must provide definition of each function.

### Templates (Next Week)