## Pointers, Classes, Virtual Functions, Abstract Classes

#pointers #classes #virtualfunctions #abstractclasses #memory

### Memory and Addresses

Each location in memory is defined by a unique address.
- Each location in memory contains a value.
- Each location is called a _byte_.

Modern machines have 8-bit bytes, which can store unsigned integers from [0, 255] or signed integers from [-128, 127].
- To store even larger values, we combine two or more bytes and treat them as a single, larger unit of memory.
- Many machines store integers in **words** (2 bytes, *i.e. `short`*) or **quads** (4 bytes, *i.e. `int`*).

![[pointers_1.png]]

### Pointers

#pointers

- Do not have a name associated with the pointer data type
	-  C++ does not have a built-in keyword like `pointer`.
- Instead, the declaration `*` is used to indicate that a variable is a pointer (12.1 - 12.3).
- The type `int*` means _pointer to int_ , but you won't see a single keyword like `pointerint`.

```cpp
dataType* identifier;
```
_Figure 12.1 - Pointer Syntax_

```cpp
int* p;
char* ch;
```
*Figure 12.2 - Pointer Example*

```cpp
// These are all equivalent
int* p;
int *p;
int * p;

// DO NOT DO THIS
// p is a pointer and q is an int
int* p, q;
```
_Figure 12.3 - Address of Operator Equivalence and Inline Declaration_

### Address of Operator (`&`)

#addressof
 
**Address of Operator (`&`)** - A unary operator that returns the address of its operand (12.4).

```cpp
int x;
int* p;

// Assigning the address of x to p
p = &x;
```
*Figure 12.4 - Address of Operator Pointer Assignment*

### Dereferencing Operator

#dereference #indirection

**Dereference Operator** (_Indirection Operator_) - When used as a unary operator, `*` refers to the object to which its operand points (12.5).

```cpp
cout << *p << '\n';
```
_Figure 12.5 - Dereferencing Operator Example_
- Prints the value stored in the memory location pointed to by `p`.

### `class`, `struct`, and Pointer Variables

#structpointer

```cpp
struct studentType {
	char name[25];
	double gpa;
}

studentType student;
studentType* studentPtr;

// Store address of student in studentPtr
studentPtr = &student;
// Store value in gpa
(*studentPtr).gpa = 3.5;
// Member access operator arrow
studentPtr->gpa = 3.5;    // Equivalent to (*studentPtr).gpa
```
*Figure 12.5 - `struct` and Pointer Example*
- `student` is an object of type `studentType`.
- `studentPtr` is a pointer var of type `studentType`.
- `()` used because member access operator has higher precedence than dereferencing operator.
	- Can use `->` instead (**Member Access Operator Arrow**).

### Initialize Pointer Variables

C++ does not automatically initialize variables.

Pointer vars must be initialized if you do not want them to point to anything.
- Use `nullptr`, the pointer literal included in modern C++ (12.6).

```cpp
int* p = nullptr;
```
*Figure 12.6 - Initializing Pointer Using `nullptr`*
- Do not use `NULL` or `0` to initialize a pointer var.

### Dynamic Variables

#dynamicvars #newoperator #deleteoperator

**Dynamic Variables** are created during program execution (run-time, not compile time).
- C++ creates dynamic vars using pointers.

`new` and `delete` operators are used to create and destroy dynamic variables.
- `new` and `delete` are reserved words in C++.

`new` has two forms (12.7):

```cpp
new dataType;            // Allocate a single var
new dataType[intExp];    // Allocate an array of variables
```
*Figure 12.7 - `new` Operator Syntax*
- `intExp` is any expression evaluating to a positive integer.
- `new` allocates memory (variable) of the designated type and returns a pointer to it.
	- The allocated memory is uninitialized.

```cpp
int* p;

// Creates a var during run-time somewhere in memory
// Stores the address of the allocated memory in `p`
p = new int;
```
*Figure 12.8 - `new` Forms Example*
- To access the allocated memory, use `*p`
	- **CANNOT** be accessed directly (b/c it is unnamed).

**Memory Leak** is previously allocated memory that cannot be reallocated.
- To avoid a memory leak, use `delete` operator to destroy a dynamic variable that is no longer needed (the memory is freed, deallocated) (12.9).

```cpp
delete pointerVariable;       // Deallocate a single dynamic var
delete [] pointerVariable;     // Deallocate a dynamically created arr
```
*Figure 12.9 - `delete` Operator Syntax*
- After memory is deallocated, pointer vars should be assigned `nullptr`.
- `pointerVariable = nullptr;`

### Operations on Pointer Variables

#pointeroperations #pointerarithmetic #pointercaution

**Assignment**: Value of pointer var can be assigned to a separate pointer var.
**Relational**: Two pointer vars of the same type can be compared for equality.
**Limited Arithmetic**:
- Integer values can be added and subtracted from a pointer var.
- Value of one pointer var can be subtracted from another pointer var.

**POINTER ARITHMETIC CAN BE DANGEROUS**
- Program can accidentally access memory locations and mutate their values.
- Systems might terminate program with an appropriate message.
- **ALWAYS** use pointers carefully and check for bounds

### Uninitialized & Illegal Pointers

```cpp
int* a;

*a = 12;    // NOT GODD
```
*12.10 - Illegal Pointer Operation*
- Garbage address
	- Illegal address (`SEGFAULT` if you are lucky).
	- Legal address (if not so lucky).

Be careful that pointers are initialized before applying indirection to them (12.11).

```cpp
int value = 42;
int* a = &value;
*a = 12;
```
*12.11 - Legal Pointer Operation*

It is **ILLEGAL** to dereference a `nullptr`
- **ENSURE IT IS NOT A `nullptr`**
- **DO NOT USE `null` OR `0` FOR POINTERS**

### Indirection & Values

```cpp
*&a = 42;
```
*12.12 - Pointer Operations - Full Circle*
- Equivalent to `a = 42` but involves more operations, and object code will be larger and slower.

### Pointer Arithmetic

#pointerarithmetic

Adding to a pointer automatically scales the pointer to the appropriate size, based on the type.

![[pointers_2.png]]
*Moves the pointer to the next memory address based on the type.*

Pointer arithmetic can be used to move from one element from an array, to the next.

![[pointers_3.png]]

You cannot perform any other arithmetic operations on pointers besides `+` or `-`.
- Only valid for pointers that are pointing at an element of an array.do 

![[pointers_4.png]]

`pointer - pointer` is only allowed when both pointers point to elements of the same array.
- The result of subtracting two pointers is of type `ptrdiff_t` which is a _signed integral_ type. Its value is the distance between the two pointers (measured in array elements, not bytes).
- assuming `vp` points to the addy *just past the end of the array*, we can computer the number of elements in the array:
```cpp
ptrdiff_t num_elements = vp - &values[0];    // CAPACITY
```
*12.13 - Pointer Subtraction*

### Relational Operators

#relationaloperators

Possible to compare two pointer values with relational operators <, <=, >=, >, only if they point to elements of the **SAME** array.
- You may test for equality or inequality between pointers.
```cpp
int b[10];
```
*12.14 - **Pointer Constant***
- The type of b[4] is `int` but the type of `b` is a **Pointer Constant**, that is, the address of the first element of the array.
- The value of this pointer cannot be mutated.
- Arrays are managed by the compiler, hence, **CANNOT** be moved.
- `[]` is called a subscript.

### Subscripts

#subscripts #indirection #pointerarithmetic

```cpp
*(b + 3)
```
*12.15 - Subscripts In Action*
- `b` is a pointer to an integer (value of 3 is scaled to size of `int` or $3 * 4 = 12$).
- Addition yields a pointer to the integer that is located $3$ integers beyond the first one in the array.
- Indirection then takes us to the new location, either to get the value there or to store a new one.
_Therefore the following statements are equivalent._
```cpp
array[sub]
*(array + sub)
```
*12.16 - Subscript Equivalence*

### Pointers VS Subscripts

#pointers #performance

![[pointers_6.png]]

### Dynamic Arrays

**Dynamic Array**: Array created during program execution.

```cpp
int* list = new int[10];
int* p = list;

*p = 25;    // Stores 25 in the first memory location
++p;        // Moves p to point to next array el
*p = 35;    // Stores 35 into the second memory location

delete [] list;
list = nullptr;
p = nullptr;
```
*12.17 - Dynamic Arrays*
*An array name is a `pointer constant`*.

### Functions and Pointers

#pointerparam


A pointer variable can be passed either by value or by reference.
- As a reference param in a function heading, use &:
```cpp
void PointerParameters(int*& p, double* q) {
	// p is a reference to a pointer int
	// q is a copy of a pointer to double
}
```
*12.18 - Pointers as Parameters*
### Pointers and Function Return Values

#pointerreturn

```cpp
int* testExp(...) {
	// ...
}
```
*12.19 - Pointers as Function Return Values*

### Dynamic Two-Dimensional Arrays

#2dpointerarray

```cpp
// Board is an array of four pointers to int
int* board[4];

for (int row = 0; row < 4; ++ row;) {
	board[row] = new int[6]:    // Create new board rows
}

// Board is a pointer to an int
int** boardPtr = nullptr;
```
*12.20 - Dynamic Two-Dimensional Arrays*

### Shallow Copy VS Deep Copy and Pointers

#shallowcopy #deepcopy #classpointer

**Shallow Copy**: When two or more pointers of the same type point to the same memory.
- They point to the same data.
- **DANGER**: When deleting one pointer, deletes data for all pointers.

**Deep Copy**: When the contents of the memory pointed to by a pointer are copied to the memory location of another pointer.
- Each pointer has its own data

```cpp
class Blob {
public: 
    int* p;

	// Default constructor
	Blob() { p = nullptr; }
};

int main() {
    Blob a;
    a.p = new int;
    *(a.p) = 5;

    // Shallow copy
	// Need to rewrite functionality of assignment operator
    Blob b = a;
    std::cout << *(b.p);

    return 0;
}
```
*12.21 - Shallow Copy*
_In order to create a deep copy, a **Copy Constructor** is needed. Deleting the value of p will leave the memory address marked elsewhere and could cause a memory leak._

### Destructor

#destructor #classpointer 

Ensure that dynamic memory is deallocated.

```cpp
// Destructor deletes the dynamic variable
Blob::~Blob() {
	delete p;
}
```
*12.22 - Destructor Removing Pointer*

### Assignment Operator

Extend definition of the assignment operator to avoid deep copying of data (not covered in this chapter).

### Copy Constructor

#copyconstructor #classpointer #ruleofthree

**Default Member-Wise initialization*
- Initializing a class object by using the value of an existing object of the same type.

```cpp
ptrMemberVar objTwo(objOne);
```
*12.23 - Copy Constructor Usage Syntax*

```cpp
Blob::Blob(const Blob other) {
	p = new int;
	*p = *(other.p);	
}
```
*12.24 - Copy Constructor Implementation (Deep Copy)*
_The data of `other` is cloned so the param can be `const`._

If the **Copy Constructor** is not provided, the compiler will do it, causing a shallow copy of the data to be created (if the obj has pointer data).

#### RULE OF THREE
For classes with pointer member variables:
	1. Include the destructor in the class.
	2. Overload the assignment operator for the class.
	3. Include the copy constructor.

### Inheritance, Pointers, and Virtual Functions

#inheritance #virtualfunctions #runtimebinding #compiletimebinding #latebinding #dynamicbinding

Can pass an object of a derived class to a formal param of the base class.

**Compile-time Building**: The necessary code to call a specific function is generated by compiler.
- A.K.A. **Static Binding** or **Early Binding**

**Virtual Function**: Binding occurs at program execution time, not at compile time.
- Declared with reserved word `virtual`.
- For example, overriding a function from a base class (same function signature) the derived class and attempting to use the overridden function (derived class function) from a pointer that points to any object of the base class (in this case it points to the derived class), will result in the base class function being called. In these scenarios, Use the keyword `virtual` for both function definitions.

**Run-Time Binding**:
- Compiler does not generate code to call a specific function. It generates information to enable the run-time system to generate specific code for the function call.
- A.K.A **Late Binding** or **Dynamic Binding**
- Note: Cannot pass obj of base class type to a formal param of the derived class type.

Values of the derived class obj can be copied into a base class obj.
- **Slicing Problem**: If derived class has more data members than base class, some data could be lost.
- Solution: use pointers for both base and derived class objs.

## Classes and Virtual Functions

#virtualfunctions #classes #virtualdestructor

Classes with pointer member variables should have a destructor.
- Destructor should deallocate memory for dynamic objs.

If a derived class obj is passed as a formal param of the base class type, the destructor of the base class executes (due to early binding).
- Regardless of whether obj is passed by ref or by value.

**Solution**: Use **Virtual Destructor** (base class)

```cpp
virtual pointerMemberVarType::~pointerMemberVarType();
```
*12.25 - Virtual Destructor (Base Class)*
_Will perform late binding and do the destructor of the derived class rather than the base class._

**Virtual Destructor** of a base class automatically makes the destructor of a derived class virtual.
- After executing the destructor of the derived class, the destructor of the base class executes.
- If a base class contains virtual functions, make the destructor of the base class virtual.

### Abstract Classes and Pure Virtual Functions

#abstractclasses #virtualfunctions 

Derived Classes:
- Inherit existing members of base class
- Can add their own members.
- Can redefine or override `public` and `protected` member functions.

Instead of defining functions in the base class that we want all derived classes to posses, we can declare **Pure Virtual Functions** (not defined).

```cpp
virtual void draw() = 0;
```
*12.26 - Pure Virtual Function*

**Abstract Class** is a class with one or more **Pure Virtual** functions.
- It can contain instance variables, constructors, and functions that are not purely virtual.
- It must provide definitions of any constructor and non-pure-virtual functions.
- It cannot be instantiated directly.

### Address of Operator

#addressof

`&` can be used to create an alias to an obj. Whatever happens to the reference, also happens to the original variable/obj.
- Can also be used to return the address of a private member variable of a class.
- **WARNING**: If you are not careful, this operation can result in serious errors in the program.