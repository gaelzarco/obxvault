## Pointers, Classes, Virtual Functions, Abstract Classes

#pointers #classes #virtualfunctions #abstractclasses #memory

### Memory and Addresses

Each location in memory is defined by a unique address.
- Each location in memory contains a value.
- Each location is called a _byte_.

Modern machines have 8-bit bytes, which can store unsigned integers from [0, 255] or signed integers from [-128, 127].
- To store even larger values, we combine two or more bytes and treat them as a single, larger unit of memory.
- Many machines store integers in **words** (2 bytes, *i.e. `short`*) or **quads** (4 bytes, *i.e. `int`*).

![[pointers_1.png]]

### Pointers

#pointers

- Do not have a name associated with the pointer data type
	-  C++ does not have a built-in keyword like `pointer`.
- Instead, the declaration `*` is used to indicate that a variable is a pointer (12.1 - 12.3).
- The type `int*` means _pointer to int_ , but you won't see a single keyword like `pointerint`.

```cpp
dataType* identifier;
```
_Figure 12.1 - Pointer Syntax_

```cpp
int* p;
char* ch;
```
*Figure 12.2 - Pointer Example*

```cpp
// These are all equivalent
int* p;
int *p;
int * p;

// DO NOT DO THIS
// p is a pointer and q is an int
int* p, q;
```
_Figure 12.3 - Address of Operator Equivalence and Inline Declaration_

### Address of Operator (`&`)

#addressof
 
**Address of Operator (`&`)** - A unary operator that returns the address of its operand (12.4).

```cpp
int x;
int* p;

// Assigning the address of x to p
p = &x;
```
*Figure 12.4 - Address of Operator Pointer Assignment*

### Dereferencing Operator

#dereference #indirection

**Dereference Operator** (_Indirection Operator_) - When used as a unary operator, `*` refers to the object to which its operand points (12.5).

```cpp
cout << *p << '\n';
```
_Figure 12.5 - Dereferencing Operator Example_
- Prints the value stored in the memory location pointed to by `p`.

### `class`, `struct`, and Pointer Variables

#structpointer

```cpp
struct studentType {
	char name[25];
	double gpa;
}

studentType student;
studentType* studentPtr;

// Store address of student in studentPtr
studentPtr = &student;
// Store value in gpa
(*studentPtr).gpa = 3.5;
// Member access operator arrow
studentPtr->gpa = 3.5;    // Equivalent to (*studentPtr).gpa
```
*Figure 12.5 - `struct` and Pointer Example*
- `student` is an object of type `studentType`.
- `studentPtr` is a pointer var of type `studentType`.
- `()` used because member access operator has higher precedence than dereferencing operator.
	- Can use `->` instead (**Member Access Operator Arrow**).

### Initialize Pointer Variables

C++ does not automatically initialize variables.

Pointer vars must be initialized if you do not want them to point to anything.
- Use `nullptr`, the pointer literal included in modern C++ (12.6).

```cpp
int* p = nullptr;
```
*Figure 12.6 - Initializing Pointer Using `nullptr`*
- Do not use `NULL` or `0` to initialize a pointer var.

### Dynamic Variables

#dynamicvars #newoperator #deleteoperator

**Dynamic Variables** are created during program execution (run-time, not compile time).
- C++ creates dynamic vars using pointers.

`new` and `delete` operators are used to create and destroy dynamic variables.
- `new` and `delete` are reserved words in C++.

`new` has two forms (12.7):

```cpp
new dataType;            // Allocate a single var
new dataType[intExp];    // Allocate an array of variables
```
*Figure 12.7 - `new` Operator Syntax*
- `intExp` is any expression evaluating to a positive integer.
- `new` allocates memory (variable) of the designated type and returns a pointer to it.
	- The allocated memory is uninitialized.

```cpp
int* p;

// Creates a var during run-time somewhere in memory
// Stores the address of the allocated memory in `p`
p = new int;
```
*Figure 12.8 - `new` Forms Example*
- To access the allocated memory, use `*p`
	- **CANNOT** be accessed directly (b/c it is unnamed).

**Memory Leak** is previously allocated memory that cannot be reallocated.
- To avoid a memory leak, use `delete` operator to destroy a dynamic variable that is no longer needed (the memory is freed, deallocated) (12.9).

```cpp
delete pointerVariable;       // Deallocate a single dynamic var
delete []pointerVariable;     // Deallocate a dynamically created arr
```
*Figure 12.9 - `delete` Operator Syntax*
- After memory is deallocated, pointer vars should be assigned `nullptr`.
- `pointerVariable = nullptr;`

### Operations on Pointer Variables

#pointeroperations #pointerarithmetic #pointercaution

**Assignment**: Value of pointer var can be assigned to a separate pointer var.
**Relational**: Two pointer vars of the same type can be compared for equality.
**Limited Arithmetic**:
- Integer values can be added and subtracted from a pointer var.
- Value of one pointer var can be subtracted from another pointer var.

**POINTER ARITHMETIC CAN BE DANGEROUS**
- Program can accidentally access memory locations and mutate their values.
- Systems might terminate program with an appropriate message.
- **ALWAYS** use pointers carefully and check for bounds

### Uninitialized & Illegal Pointers

```cpp
int* a;

*a = 12;    // NOT GODD
```
*12.10 - Illegal Pointer Operation*
- Garbage address
	- Illegal address (`SEGFAULT` if you are lucky).
	- Legal address (if not so lucky).

Be careful that pointers are initialized before applying indirection to them (12.11).

```cpp
int value = 42;
int* a = &value;
*a = 12;
```
*12.11 - Legal Pointer Operation*

It is **ILLEGAL** to dereference a `nullptr`
- **ENSURE IT IS NOT A `nullptr`**
- **DO NOT USE `null` OR `0` FOR POINTERS**

### Indirection & Values

```cpp
*&a = 42;
```
*12.12 - Pointer Operations - Full Circle*
- Equivalent to `a = 42` but involves more operations, and object code will be larger and slower.

### Pointer Arithmetic

#pointerarithmetic

Adding to a pointer automatically scales the pointer to the appropriate size, based on the type.

![[pointers_2.png]]
*Moves the pointer to the next memory address based on the type.*

Pointer arithmetic can be used to move from one element from an array, to the next.

![[pointers_3.png]]

You cannot perform any other arithmetic operations on pointers besides `+` or `-`.
- Only valid for pointers that are pointing at an element of an array.do 

![[pointers_4.png]]

`pointer - pointer` is only allowed when both pointers point to elements of the same array.
- The result of subtracting two pointers is of type `ptrdiff_t` which is a _signed integral_ type. Its value is the distance between the two pointers (measured in array elements, not bytes).
- assuming `vp` points to the addy *just past the end of the array*, we can computer the number of elements in the array:
```cpp
ptrdiff_t num_elements = vp - &values[0];    // CAPACITY
```
*12.13 - Pointer Subtraction*

### Relational Operators

#relationaloperators

Possible to compare two pointer values with relational operators <, <=, >=, >, only if they point to elements of the **SAME** array.
- You may test for equality or inequality between pointers.

```cpp
int b[10];
```
*12.14 - **Pointer Constant***
- The type of b[4] is `int` but the type of `b` is a **Pointer Constant**, that is, the address of the first element of the array.
- The value of this pointer cannot be mutated.
- Arrays are managed by the compiler, hence, **CANNOT** be moved.
- `[]` is called a subscript.

### Subscripts

#subscripts #indirection #pointerarithmetic

```cpp
*(b + 3)
```
*12.15 - Subscripts In Action*
- `b` is a pointer to an integer (value of 3 is scaled to size of `int` or $3 * 4 = 12$).
- Addition yields a pointer to the integer that is located $3$ integers beyond the first one in the array.
- Indirection then takes us to the new location, either to get the value there or to store a new one.
_Therefore the following statements are equivalent._
```cpp
array[sub]
*(array + sub)
```
*12.16 - Subscript Equivalence*

### Pointers VS Subscripts

#pointers #performance

![[pointers_6.png]]