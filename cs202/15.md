## Recursion

### Definition(s)

#recursion #recursive #basecase #generalcase

**Recursion**: Solving a problem by reducing it to smaller versions of itself.

**Recursive**: A definition of something defined in terms of a smaller version of itself.

**Base Case**: The case for which the solution is obtained directly.
- Every recursive definition must have at least one base case.

The **General Case** must eventually reduce to a base case.
- The base case stops the recursion.

### Example(s)

#recursiveexamples #recursivecallstack

```
1. 0! = 1
2. n! = n * (n - 1)! if n > 0
```
_Figure 15.1 - Factorial Base Case & General Case_
- _Line 1_ is the base case.
- _Line 2_ is the general case.

```cpp
// Direct, recursive factorial function
unsigned factorial  (unsigned n) {
	// Base case
	if (n == 0 || n == 1) {
		return 1;
	}
	
	// General case
	return n * factorial(n - 1);
}
```
_Figure 15.2 - Factorial Function Implementation_
- Recursive functions may require and use multiple `return` statements.

```
factorial(4)
	-> 4 * factorial(3)
		-> 3 * factorial(2)
			-> 2 * factorial(1)
				-> 1
```
_Figure 15.3 - Factorial Function Call Stack_
- As calls unwind, final result is `4 * 3 * 2 * 1 = 24`

### Comparing Iterative V.S. Recursive Factorial

#iterativevsrecursive

```cpp
// Iterative approach
unsigned factorial_iterative(unsigned n) {
	unsigned result = 1;
	for (unsigned i = 1; i <= n; ++i) {
		result *= i;
	}
	return result;
}

// Recursive approach
unsigned factorial_recursive(unsigned n) {
	if (n == 0) return 1;
	return n * factorial_recursive(n - 1);
}
```
_Figure 15.4 - Factorial: Iterative V.S. Recursive_
- Iteration avoids function-call overhead but recursion can be clearer.
- Both produce similar results.

### Definition(s) _Continued_

#recursivealgorithm #recursivefunction

**Recursive Algorithm**: Finds a solution to a problem by reducing the problem to smaller versions of itself.
- Must have one or more base case(s).
- General solution must reduce to a base case.

**Recursive Function**: A function that calls itself.
- Used to implement recursive algorithms.

Think of recursive functions as having infinitely many copies of itself.
- Every call has its own code and its own set of params and local vars.

After completing a recursive call:
- Control goes back to the calling environment (the previous call; call stack).
- Execution begins from the points immediately following the recursive call (call stack).

### Direct & Indirect Recursion

#directlyrecursive #indirectlyrecursive #tail-recursivefunction

**Directly Recursive**: A function that calls itself.

**Indirectly Recursive**: A function that calls another function and eventually resolves in the original function call.

**Tail-Recursive Function**:  A recursive function in which the last statement executed is the recursive call.

```cpp
void foo(int n) {
	if (n >= 1) {
		std::cout << 2 * n - 1 << ' ';
		bar(n - 1);
	}
}

void bar(int n) {
	if (n >= 1) {
		std::cout << 2 * n << ' ';
		foo(n - 1);
	}
}
```
_Figure 15.5 - Indirect Recursion Example_
- `foo` and `bar` call each other, leading to recursive behavior indirectly.

In **Tail Recursion**, the recursive call is the final action taken by the function.
- Allows for possible optimizations like tail-call optimization (**C++14** does **NOT** guarantee this).
- A tail-recursive function can often be written in an iterative style.

### Tail Recursion in C++14

#tailrecursive #cpp14

**Tail Recursive** version of functions can optimize recursive calls by eliminating the need for immediate results, provided that the recursive call is the last action in the function.

```cpp
// Tail-recursive factorial function (optimized for tail recursion)
unsigned factorial_helper(unsigned n, unsigned acc) {
	// Base case
	if (n == 0 || n == 1) {
		return acc;
	}

	// Recursive call
	return factorial_helper(n - 1, n * acc);
}

// Driver function
unsigned factorial_tail(unsigned n) {
	return factorial_helper(n, 1);
}
```
_Figure 15.6 - Tail Recursive Factorial Implementation_

In **C++14**, tail recursion optimization is not guaranteed by the standard.
- Some compilers may optimize tail recursion when the recursive call is the last operation in the function, however this is implementation-dependent.

### Memory and Time Complexity Consideration(s)

#recursionmemorycomplexity #recursiontimecomplexity

**Stack Usage**:
- Each recursive call stores params/local vars on the call stack.
- Deep recursion can risk stack overflow if the recursion depth is too large.

**Time Complexity**:
- Simple recursive algorithms (like factorial) take $O(n)$ time.
- Recursion V.S. iteration: Recursion can be elegant but incurs function-call overhead.

### Divide-and-Conquer Algorithm(s)

#divide-and-conquer #binarysearch

**Divide-and-Conquer**: A recursive algorithm design technique where problems are broken down into smaller sub-problems, solved independently, and combined to form the final solution.

Commonly used in search and sorting algorithms (_e.g._ **Binary Search** and **Merge Sort**).

```cpp
int* binary_search(int* first, int* last, int target) {
	if (first == last) {
		return last;
	}
	
	int* mid = first + (last - first) / 2;
	
	if (*mid == target) {
		// Base case: target found
		return mid;
	} else if (*mid > target) {
		// Search lower half
		return binary_search(first, mid, target);
	} else {
		// Search upper half
		return binary_search(mid + 1, last, target);
	}
}
```
_Figure 15.7 - Binary Search with Pointers_
- Divides the problem by halving the search range in each recursive step.
- if target not found, function returns the last pointer (one-past-the-last-element).
- Efficient for large datasets because the search is split into smaller, more manageable pieces.

### Backtracking

#backtracking #mazealgorithm

**Backtracking**: Recursive approach that incrementally builds a solution, removing invalid solutions as soon as they are detected.
- Useful in constraint satisfaction problems (_e.g._ Solving mazes, puzzles, or **N-Queens**).

```
function solve_maze(maze, row, col) -> bool:
	if (row, col) if out of bounds or maze[row][col] != 0:
		return false
	
	if (row, col) is equal to (rows-1, cols-2) (the exit):
		mark (row, col) as part of the path (9)
		return true
	
	mark (row, col) as part of the path (9)
	
	if solve_maze(maze, row, col + 1): return true // move east if 
	solve_maze(maze, row + 1, col): return true    // move south if 
	solve_maze(maze, row, col - 1): return true    // move west if 
	solve_maze(maze, row - 1, col): return true    // move north
	
	unmark (row, col) as part of the path (backtrack)
	return false
```
_Figure 15.8 - Solving a Maze Algorithm_
- Explores multiple solutions but abandons paths that do not work.
- Useful for problems where there are multiple valid solutions or when you need to try all possibilities.