## Rvalue References

#rvaluereference #lvaluereference #movesemantics 

### Rvalue References in Detail

**Lvalue References** are declared with a single ampersand
- Rvalue references are declared with double ampersands.

**Rvalue References** refer over their lifetime to an existing object.
- Have to be passed as an initial value.
- Can only refer to a temp obj not having a name or an object marked with `std::move()`.

```cpp
std::string returnStringByValue();       // Forward declaration
// ...
std::string s{"hello"};
// ...
std::string&& r1{std::move(s)};           // OK
std::string&& r2{returnStringByValue()};  // OK, extends lifetime of return value
std::string&& r3{s};                      // ERROR
```
_Figure 13_1.1 - Rvalue References in Action_

Temp objs without a name and objs marked with `move` are **Rvalues**.

_Rvalue references_ can only refer to _rvalues_.
- Syntax used to initialize does not affect this.

Successful initializations of references from return values cause the references to extend the lifetime of the returned value until the end of the lifetime of the references (ordinary `const` lval references already have this behavior).

```cpp
std::string s{"hello"};
// ...
std::string&& r1{std::move(s)};           // OK, reference to s
std::string&& r2 = std::move(s);          // OK, reference to s
std::string&& r3(std::move(s));           // OK, reference to s
```
_Figure 13_1.2 - Rvalue References Syntax Independent_
- You can use braces, equal sign, or parentheses.
- Rval references can steal/modify the obj they refer to as long as the state of the obj remains valid.
	- Not checked by compiler, so the rval reference can be modified similarly to a non-`const` obj of the type (or may not be modified at all).

$\therefore$ If you have an rval ref to an obj -> the obj might get a different value (may or may not be default-constructed obj) or keep its value.

Move semantics enables you to use a value from a source that is going to free the value from memory.
- If compiler detects that a val is used from an obj at the end of its lifetime -> it auto switches to move semantics.

Auto switch to move semantics when:
- Passing the val of a temp obj, which will auto destroy after the statement.
- Passing an obj marked with `std::move()`.

### Rvalue References as Parameters

Declaring a param to be an rval ref has exactly the same behavior and semantics as indicated previously.
- Can only bind to a temp obj not having a name or that is marked with `std::move()`.
- You can modify the obj it refers to.
- According to semantics:
	- Caller is no longer interested in the value, however it _might_ continue to use the obj.
	- Any modifications to the referenced obj should keep it in a valid state.

```cpp
void foo(std::string&& rv);  // takes only objects where we no longer need the value
// ...
std::string s{"hello"};
// ...
foo(s);                      // ERROR
foo(std::move(s));           // OK, value of s might change
foo(returnStringByValue());  // OK
```
_Figure 13_1.3 - Rvalue References as Parameters_
- `std::move()` enables a _named_ obj to be passed, however, you should typically avoid this.
	- _Recommended to not use an obj anymore after a `std::move()`_.

```cpp
void foo(std::string&& rv);  // takes only objects where we no longer need the value
// ...
std::string s{"hello"};
// ...
foo(std::move(s));           // OK, value of s might change
std::cout << s << '\n';      // OOPS, you don't know which value is printed
foo(std::move(s));           // OOPS, you don't know which value is passed
s = "hello again";           // OK, but rarely done
foo(std::move(s));           // OK, value of s might change
```
_Figure 13_1.4 - Rvalue References as Parameters Warnings_
- Lines marked `OOPS` are technically OK as long as you are not concerned with what `s` actually is.

### `std::move()`

#move 

If you have an obj with a lifetime that does not end when using it -> you can mark it with `std::move()` to express _"This val is no longer needed here."_
- `std::move()` does not move; it only sets a temp marker in the context of where it is used.

```cpp
void foo(const std::string& lr);  // binds to the passed object without modifying it
void foo(std::string&& rv);       // binds to the passed object and might steal/modify the value
// ...
std::string s{"hello"};
// ...
foo(s);                           // calls the first foo(), s keeps its value
foo(std::move(s));                // calls the second foo(), s might lose its value
```
_Figure 13_1.5 - Rvalue References Passed with `std::move()`_

```cpp
void foo(const std::string& lr);  // binds to the passed object without modifying it
// ...                            // no other overload of foo()
std::string s{"hello"};
// ...
foo(s);                           // calls the first foo(), s keeps its value
foo(std::move(s));                // also calls the first foo(), s keeps its value
```
_Figure 13_1.6 - Rvalue References Passed with `std::move()` as `const` lvalue Reference Parameters_
- Objs marked with `std::move()` can be passed to a function taking a `const` lvalue reference.

The same cannot be said with functions that take a non-`const` lvalue reference:
```cpp
void foo(std::string&);           // modifies the passed argument
// ...
std::string s{"hello"};
// ...
foo(s);                           // OK
foo(std::move(s));                // ERROR
```
_Figure 13_1.7 - Rvalue References Passed with `std::move()` as Non-`const` lvalue Reference Parameters_
- Results in an error.

_Note: It does not make sense to mark a dying object with `std::move()`. This can be counter-productive (source? why? trust me bro)._

`std::move()` is defined in `#include <utility>`.

It is also nothing more than a `static_cast` to an rval ref:
```cpp
foo(static_cast<std::string&&>(s));    // same as foo(std::move(s))
```
_Figure 13_1.8 - `std::move()` Implementation_
- `static_cast` does a bit more than only changing the type of the obj.
	- Enables passing the obj to an rval reference (objs with names are not usually allowed to be passed to rval references).

### Overloading by Different References

#rvalueoverloading

Three ways to pass-by-reference:
```cpp
/* (1) */ void foo(const std::string& arg)
```
_Figure 13_1.9 - Pass-By-Reference using `const` lvalue Reference_
- Provides read access to passed arg that accepts:
	- Modifiable _named_ obj.
	- `const` _named_ obj.
	- Temp obj w/o name.
	- Obj marked with `std::move()`
- Semantically means read access is given to `foo()` to the passed arg. Known also as an _In_ parameter.
```cpp
/* (2) */ void foo(std::string& arg)
```
_Figure 13_1.10 - Pass-By-Reference using Non-`const` lvalue Reference_
- Provides write access to passed arg that only accepts:
	- Modifiable _named_ obj.
- Semantically means write/read access is given to `foo()` to the passed arg. Known also as an _Out_ or _In/Out_ parameter.
```cpp
/* (3) */ void foo(std::string&& arg)
```
_Figure 13_1.11 - Pass-By-Reference using Non-`const` Rvalue Reference_
- Provides write access to passed arg that accepts:
	- Temp obj w/o a name.
	- Non-`const` obj marked with `std::move()`.
- Semantically means write access is given to `foo()` to the passed arg to steal the value (caller no longer needs value.

### `const` Rvalue References

Technically, there is a fourth way to pass-by-reference:
```cpp
/* (4) */ void foo(const std::string&& arg)
```
_Figure 13_1.12 - Pass-By-Reference using `const` Rvalue Reference_
- Provides read access to passed arg that accepts:
	- Temp obj w/o a name.
	- `const` or non-`const` obj marked with `std::move()`.
- However, no useful semantics. Rval references are allowed to steal the value, but being `const`, it contradicts its original function.
- Creating objs with this behavior happens easily.

```cpp
const std::string s{"data"};
// ...
foo(std::move(s));    // would call a function declared as const rvalue reference
```
_Figure 13_1.13 - `const` Rvalue Reference in Action_

### Passing-by-Value

If you declare a function taking an arg by value, move semantics may also automatically be applied.

```cpp
void foo(std::string str);  // takes the object by value
// ...
std::string s{"hello"};
// ...
foo(s);                     // calls foo(), str becomes a copy of s
foo(std::move(s));          // calls foo(), s is moved to str
foo(returnStringByValue()); // calls foo(), return value is moved to str
```
_Figure 13_1.14 - Move Semantics Passing-By-Value_

```
// TODO
```